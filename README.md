# Code_Based_Homomorphic_Crypto


# 20201120

Niederreiter暗号は加法準同型暗号である

https://qiita.com/herumi/items/d8645efe2cc5be2e7ee3（参考）

私の前回の記事

https://qiita.com/fumumue/items/1849e283dc213a6f55f6

の中で、符号を用いて紛失通信を実現する方法を考えましたが、
これもエラーベクトルとシンドロームのある性質を使っていると言えます。

つまり、２つの異なるエラーベクトルx,yがあり、公開鍵Hがあった時、

```math
xH⊕yH=(x⊕y)H　（⊕は排他的論理和）
```

が成り立つことで紛失通信を実現していたのでした。
これは、暗号文がＸＯＲに関する準同型をなしていることになります。

また加法が成り立つとして以下のような計算もできることになります。

エラーベクトルeに対して、シンドロームをsとする。
この時、

```math
(ne)H=(n)s
```

ここでnは有限体の任意の元とする。

問題なのは、２つのエラーベクトルの重みを合わせても必ずハミング重みがｔにならないといけないということ。
つまりランダムに選んだお互いのエラーが重なったりしてｔ以下になってしまうとうまく復号できない。
そもそもエラー訂正能力がｔなので、ｔ以上のエラーは選択できない。

でもここでちょっとずるいことをすれば、いつもtにすることができる。
それは、符号の前半と後半部分にそれぞれ、ハミング重みがt/2のエラーベクトルを入れることだ。
こういう約束をすれば、エラーのハミング重みはいつもｔになり、やり直す必要がなくなる。
そしてｔは復号するときにいずれは知る必要があるので、このようなやり方をしても問題ないことになる。

こんなごく自然な事でも、ネットでcode based homomorphic で検索してもまともな研究論文は見つかりませんでした。
で、自分で考えたらすぐわかった。
もしかしたらもうすでに研究ではわかっていることかもしれないし、単にそれが検索で引っかからなかったという可能性もあります。
なので、ちょっと誰かに協力してもらって研究調査する必要があります。

まだきちんと確かめてないのですが、この方式はおそらく完全準同型にはならないと思います。
つまり符号ベースの場合、２つのエラーが０でないにもかかわらず、掛け算の結果シンドロームが０になる可能性が高いです。
これでは困るので工夫する必要があります。

ちなみにx,y二つのエラーベクトルの合併（ＸＯＲ）したシンドロームでは、
一般に元のエラーベクトルのハミング重みが増えるために復号できません。
しかしエラーベクトルの重みを工夫すれば、もっと面白そうな機能を実現できそうです。

この暗号をL2準同型暗号に機能拡張したり、安全性の証明をつけたりしたら面白そうです。
もし研究が成功したら、次世代暗号のファイナリストを使った研究なので、一躍フィーバーしそうですねｗ。

