# Code_Based_Homomorphic_Crypto


# 20201120

準同型暗号
https://qiita.com/herumi/items/d8645efe2cc5be2e7ee3



私の前回の記事(Niederrteiter暗号は加法準同型暗号かも？)

https://qiita.com/fumumue/items/1849e283dc213a6f55f6

の中で、符号を用いて紛失通信を実現する方法を考えましたが、
これもエラーベクトルとシンドロームのある性質を使っていると言えます。

つまり、２つの異なるエラーベクトルx,yがあり、公開鍵Hがあった時、

xH ^ yH = (x^y)H　（ ^ は排他的論理和）

が成り立つことを利用して紛失通信を実現していたのでした。
これは、暗号文がＸＯＲに関する準同型をなしていることになります。

また加法が成り立つとして以下のような計算もできることになります。

エラーベクトルeに対して、シンドロームをsとする。
この時、


(ne)H=(n)s


ここでnは有限体の任意の元とする。

準同型暗号を作ろうとするとき、何を知られたらダメなのかを理解していないので無謀なことをしている可能性があります。
その時はこのリポジトリを削除します。

問題なのは、２つのエラーベクトルの重みを合わせても必ずハミング重みがｔにならないといけないということ。
つまりランダムに選んだお互いのエラーが重なったりしてｔ以下になってしまうとうまく復号できない。
そもそもエラー訂正能力がｔなので、ｔ以上のエラーは選択できない。


こんなごく自然な事でも、ネットでcode based homomorphic で検索してもまともな研究論文は見つかりませんでした。
もしかするととんでもない間違いをしているのかもしれない。
誰もそんな馬鹿なことをしていないからないだけなのかもしれない。
もしかしたらもうすでに研究ではわかっていることかもしれないし、単にそれが検索で引っかからなかったという可能性もあります。

まだきちんと確かめてないのですが、この方式はおそらく完全準同型にはならないと思います。

ちなみにx,y二つのエラーベクトルの合併（ＸＯＲ）したシンドロームでは、
一般に元のエラーベクトルのハミング重みが増えるために復号できません。
しかしエラーベクトルの重みを工夫すれば、もっと面白そうな機能を実現できそうです。

この暗号をL2準同型暗号に機能拡張したり、安全性の証明をつけたりしたら面白そうです。
もし研究が成功したら、次世代暗号のファイナリストを使った研究なので、一躍フィーバーしそうですねｗ。

